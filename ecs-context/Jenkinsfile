#!/bin/groovy

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'Deploy',
            description: 'Determines whether to deploy or to destroy the ECS cluster',
            defaultValue: false
        )
        booleanParam(
            name: 'OnlyRestart',
            description: 'Does a check for the status of the cluster first before restarting',
            defaultValue: true
        )
    }

    environment {
        AWS = credentials('AWS-Key')
        AWS_REGION = credentials('AWS-Region')
        SECRET_URL = credentials('AWS-ECS-Secrets')
        COMPOSE_PROJECT_NAME = "ap-utopia"

        VPC_NAME = "AP_TF_VPC"
        ALB_NAME = "ap-utopia-load-balancer"

        def aws_script = "aws secretsmanager get-secret-value --secret-id $SECRET_URL --region $AWS_REGION"
        def output = sh(returnStdout: true, script: aws_script)
        def aws_secrets = readJSON(text: readJSON(text: output).SecretString)

        def vpc_script = "aws ec2 describe-vpcs --region $AWS_REGION --query 'Vpcs[?Tags[?Key==`Name`]|[?Value==`$VPC_NAME`]].VpcId' --output text"
        def alb_script = "aws elbv2 describe-load-balancers --region $AWS_REGION --names $ALB_NAME --query LoadBalancers[0].LoadBalancerArn --output text"

        VPC_ID = sh(returnStdout: true, script: vpc_script)
        ALB_ID = sh(returnStdout: true, script: alb_script)

        SPRING_DATASOURCE_URL = aws_secrets["SPRING_DATASOURCE_URL"].toString()
        MYSQL_USER = aws_secrets["MYSQL_USER"].toString()
        MYSQL_PASSWORD = aws_secrets["MYSQL_PASSWORD"].toString()

        AWS_USER_ID = aws_secrets["AWS_USER_ID"].toString()

        USERS_TAG = aws_secrets["USERS_TAG"].toString()
        FLIGHTS_TAG = aws_secrets["FLIGHTS_TAG"].toString()
        BOOKINGS_TAG = aws_secrets["BOOKINGS_TAG"].toString()

        USERS_PORT = aws_secrets["USERS_PORT"].toString()
        FLIGHTS_PORT = aws_secrets["FLIGHTS_PORT"].toString()
        BOOKINGS_PORT = aws_secrets["BOOKINGS_PORT"].toString()

        DOCKER_CMD = "/usr/local/bin/docker"
    }

    stages {
        stage('Setup Docker Context') { steps{ script{
            def status = sh(returnStatus: true, script: '$DOCKER_CMD context ls | grep aws_context')
            if (status != 0) {
                echo(message: 'AWS context does not exist!')
                sh(script: "$DOCKER_CMD context create ecs --from-env aws_context")
            }

            sh(script: '$DOCKER_CMD context use aws_context')
            sh(script: "aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${AWS_USER_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com")
        }}}
        stage('GitHub Fetch') { steps{
            echo(message: 'GitHub Fetch!')
            git(branch: 'dev', url: 'https://github.com/Heads-in-the-Cloud/devops-AP.git')
        }}

        // Conditional deployment
        stage('Deploy ECS') { when { expression { params.Deploy && !params.OnlyRestart }}
            steps {
            dir(path: './ecs-context') {
                sh(script: "$DOCKER_CMD compose up")
            }
        }}
        stage('Restart ECS service') { when { expression { params.Deploy && params.OnlyRestart }}
            steps {
            dir(path: './ecs-context') { script{
                def status = sh(returnStatus: true, script: '$DOCKER_CMD compose ps | grep $COMPOSE_PROJECT_NAME')
                if (status != 0) {
                    echo(message: 'Cluster is down so no need to restart services.')
                } else {
                    sh(script: "$DOCKER_CMD compose up")
                }
            }}
        }}

        // Destroy ECS
        stage('Takedown ECS') { when { expression { !params.Deploy }}
            steps {
            dir(path: './ecs-context') {
                sh(script: "$DOCKER_CMD compose down")
            }
        }}
    }
    post { always {
        sh(script: "$DOCKER_CMD context use default")
    }}
}