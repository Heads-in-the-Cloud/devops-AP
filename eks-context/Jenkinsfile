#!/bin/groovy

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'Deploy',
            description: 'Determines whether to deploy or to destroy the EKS cluster',
            defaultValue: false
        )
        choice(
            name: 'Service',
            description: 'Determines which services to deploy / restart',
            choices: [ 'all', 'users', 'flights', 'bookings' ]
        )
    }

    environment {
        AWS = credentials('AWS-Key')
        AWS_REGION = credentials('AWS-Region')
        EKSCTL_CMD = "/usr/local/bin/eksctl"

        // --- Secrets Retrieval
        SECRET_URL = credentials('AWS-Services-Secret')
        EKS_SECRET_URL = credentials('AWS-EKS-Secrets')
        RESOURCE_SECRETS_URL = credentials('Resource-IDs')

        def aws_output = sh(returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id $SECRET_URL --region $AWS_REGION")
        def aws_secrets = readJSON(text: readJSON(text: aws_output).SecretString)

        def eks_output = sh(returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id $EKS_SECRET_URL --region $AWS_REGION")
        def eks_secrets = readJSON(text: readJSON(text: eks_output).SecretString)

        def resource_output = sh(returnStdout: true, script: "aws secretsmanager get-secret-value --secret-id $RESOURCE_SECRETS_URL --region $AWS_REGION")
        def resource_secrets = readJSON(text: readJSON(text: resource_output).SecretString)

        KMS_KEY = eks_secrets['KMS_KEY'].toString()
        KMS_DECRYPT = "/usr/local/bin/kms-decrypt.sh $KMS_KEY"

        // --- EKS Environment Variables
        CLUSTER_NAME = eks_secrets["CLUSTER_NAME"].toString()
        NAMESPACE = eks_secrets["NAMESPACE"].toString()
        HOSTNAME = eks_secrets["HOSTNAME"].toString()

        VPC_ID = resource_secrets["VPC_ID"].toString()

        PUBLIC_SUBNET_1 = resource_secrets["PUBLIC_SUBNET_IDS"][0].toString()
        PUBLIC_SUBNET_2 = resource_secrets["PUBLIC_SUBNET_IDS"][1].toString()
        PUBLIC_SUBNET_3 = resource_secrets["PUBLIC_SUBNET_IDS"][2].toString()

        PRIVATE_SUBNET_1 = resource_secrets["PRIVATE_SUBNET_IDS"][0].toString()
        PRIVATE_SUBNET_2 = resource_secrets["PRIVATE_SUBNET_IDS"][1].toString()
        PRIVATE_SUBNET_3 = resource_secrets["PRIVATE_SUBNET_IDS"][2].toString()

        // --- Image Repository Details
        def repo_host = aws_secrets["AP-Repo-Host"].toString()

        def users_repo = aws_secrets["AP-Users-Repo"].toString()
        def flights_repo = aws_secrets["AP-Flights-Repo"].toString()
        def bookings_repo = aws_secrets["AP-Bookings-Repo"].toString()

        def users_tag = eks_secrets['USERS_TAG'].toString()
        def flight_tag = eks_secrets['FLIGHTS_TAG'].toString()
        def bookings_tag = eks_secrets['FLIGHTS_TAG'].toString()

        USERS_IMAGE = "$repo_host/$users_repo:$users_tag"
        FLIGHTS_IMAGE = "$repo_host/$flights_repo:$flight_tag"
        BOOKINGS_IMAGE = "$repo_host/$bookings_repo:$bookings_tag"
    }

    stages {
        stage('GitHub Fetch') { steps{
            echo(message: 'GitHub Fetch!')
            git(branch: 'feature-eks', url: 'https://github.com/Heads-in-the-Cloud/devops-AP.git')
        }}

        // Conditional deployment
        stage('Deploy EKS') { when { expression { params.Deploy && params.Service == 'all' }}
            steps {
                script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 0) {
                    // error(message: 'EKS Cluster already exists!')
                    echo(message: 'EKS Cluster already Exists!')
                } else {
                    dir(path: './eks-context') {
                        echo(message: 'Creating EKS Cluster since it does not exist!')
                        sh(script: "envsubst < cluster.yml | $EKSCTL_CMD create cluster --alb-ingress-access -f -")
                    }
                }
            }

            // --- Applying Kubernetes resources
            dir(path: './eks-context') {
                echo(message: 'Deploying Resources!')
                sh(script: "kubectl config set-context --current --namespace=$NAMESPACE")

                // Applying AWS ALB Configs
                sh(script: 'kubectl apply -f namespace.yml')
                sh(script: 'kubectl apply -f rbac-role.yml')
                sh(script: 'envsubst < alb-ingress-controller.yml | kubectl apply -f -')

                // Applying Secrets
                sh(script: "$KMS_DECRYPT ./secrets.yml.encrypted ./secrets.yml")

                // Launching Microservices
                sh(script: 'kubectl apply -f secrets.yml')
                sh(script: 'envsubst < deployments.yml | kubectl apply -f -')
                sh(script: 'kubectl apply -f services.yml')
                sh(script: 'envsubst < ingress.yml | kubectl apply -f -')
            }
        }}
        stage('Restart Deployment') { when { expression { params.Deploy && params.Service != 'all' }}
            steps { script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 1) {
                    error(message: 'Cluster is not up so no need to update the deployment!')
                }
            }
            sh(script: "kubectl config set-context --current --namespace=$NAMESPACE")
            sh(script: "kubectl rollout restart deployment ${params.Service}")
        }}

        // Destroy EKS
        stage('Takedown EKS') { when { expression { !params.Deploy }}
            steps { script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 1) {
                    error(message: 'EKS Cluster does not exist!')
                }
            }

            dir(path: './eks-context') {
                echo(message: 'Taking Down Messages!')
                sh(script: "$EKSCTL_CMD delete cluster --name $CLUSTER_NAME --region $AWS_REGION")
            }
        }}
    }
}