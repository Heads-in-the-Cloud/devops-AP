#!/bin/groovy

pipeline {
    agent any

    parameters {
        booleanParam(
            name: 'Deploy',
            description: 'Determines whether to deploy or to destroy the EKS cluster',
            defaultValue: false
        )
        choice(
            name: 'Service',
            description: 'Determines which services to deploy / restart',
            choices: [ 'all', 'users', 'flights', 'bookings', 'ingress' ]
        )
    }

    environment {
        AWS = credentials('AWS-Key')
        AWS_REGION = credentials('AWS-Region')
        EKSCTL_CMD = "/usr/local/bin/eksctl"

        // --- Secrets Retrieval
        SECRET_URL = credentials('AWS-Services-Secret')
        EKS_SECRET_URL = credentials('AWS-EKS-Secrets')
        RESOURCE_SECRETS_URL = credentials('Resource-IDs')
        TERRAFORM_URL = credentials("Terraform-Secrets")

        def aws_secrets = getSecret(SECRET_URL, AWS_REGION)
        def eks_secrets = getSecret(EKS_SECRET_URL, AWS_REGION)
        def resource_secrets = getSecret(RESOURCE_SECRETS_URL, AWS_REGION)
        def terraform_secrets = getSecret(TERRAFORM_URL, AWS_REGION)

        KMS_KEY = eks_secrets['KMS_KEY'].toString()
        KMS_DECRYPT = "/usr/local/bin/kms-decrypt.sh $KMS_KEY"

        // --- EKS Environment Variables
        CLUSTER_NAME = eks_secrets["CLUSTER_NAME"].toString()
        NAMESPACE = eks_secrets["NAMESPACE"].toString()
        HOSTNAME = eks_secrets["HOSTNAME"].toString()

        VPC_ID = resource_secrets["VPC_ID"].toString()

        PUBLIC_SUBNET_1 = resource_secrets["PUBLIC_SUBNET_IDS"][0].toString()
        PUBLIC_SUBNET_2 = resource_secrets["PUBLIC_SUBNET_IDS"][1].toString()
        PUBLIC_SUBNET_3 = resource_secrets["PUBLIC_SUBNET_IDS"][2].toString()

        PRIVATE_SUBNET_1 = resource_secrets["PRIVATE_SUBNET_IDS"][0].toString()
        PRIVATE_SUBNET_2 = resource_secrets["PRIVATE_SUBNET_IDS"][1].toString()
        PRIVATE_SUBNET_3 = resource_secrets["PRIVATE_SUBNET_IDS"][2].toString()

        ACCOUNT_ID = terraform_secrets["aws_user_id"].toString()
        RANDOM_ID = "123456789"

        // --- Image Repository Details
        def repo_host = aws_secrets["AP-Repo-Host"].toString()

        def users_repo = aws_secrets["AP-Users-Repo"].toString()
        def flights_repo = aws_secrets["AP-Flights-Repo"].toString()
        def bookings_repo = aws_secrets["AP-Bookings-Repo"].toString()

        def users_tag = eks_secrets['USERS_TAG'].toString()
        def flight_tag = eks_secrets['FLIGHTS_TAG'].toString()
        def bookings_tag = eks_secrets['FLIGHTS_TAG'].toString()

        USERS_IMAGE = "$repo_host/$users_repo:$users_tag"
        FLIGHTS_IMAGE = "$repo_host/$flights_repo:$flight_tag"
        BOOKINGS_IMAGE = "$repo_host/$bookings_repo:$bookings_tag"

        ELK_URL = "ap-elk.hitec.link"
    }

    stages {
        stage('GitHub Fetch') { steps{
            echo(message: 'GitHub Fetch!')
            git(branch: 'dev', url: 'https://github.com/Heads-in-the-Cloud/devops-AP.git')
        }}

        // Conditional deployment
        stage('Deploy EKS') { when { expression { params.Deploy && params.Service == 'all' }}
            steps { script {
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 0) {
                    // error(message: 'EKS Cluster already exists!')
                    echo(message: 'EKS Cluster already Exists!')
                } else {
                    dir(path: './eks-context') {
                        echo(message: 'Creating EKS Cluster since it does not exist!')
                        sh(script: "envsubst < cluster.yml | $EKSCTL_CMD create cluster --alb-ingress-access -f -")
                    }
                }
            }

            // --- Applying Kubernetes resources
            dir(path: './eks-context') {
                echo(message: 'Deploying Resources!')
                sh(script: "kubectl config set-context --current --namespace=$NAMESPACE")
                sh(script: "aws eks update-kubeconfig --name $CLUSTER_NAME --region $AWS_REGION")

                // Applying AWS ALB Configs
                sh(script: 'kubectl apply -f namespace.yml')
                sh(script: 'kubectl apply -f rbac-role.yml')
                sh(script: 'envsubst < alb-ingress-controller.yml | kubectl apply -f -')

                // Applying Secrets
                sh(script: "$KMS_DECRYPT ./secrets.yml.encrypted ./secrets.yml")

                // Launching Microservices
                sh(script: 'kubectl apply -f secrets.yml')
                sh(script: 'envsubst < deployments.yml | kubectl apply -f -')
                sh(script: 'kubectl apply -f services.yml')
                sh(script: 'envsubst < ingress.yml | kubectl apply -f -')
                sh(script: 'envsubst < fluent-bit.yml | kubectl apply -f -')

                sh(script: """aws iam create-policy \
                    --policy-name eks-fargate-logging-policy \
                    --policy-document file://permissions.json""")
                sh(script: """aws iam attach-role-policy \
                    --policy-arn arn:aws:iam::$ACCOUNT_ID:policy/eks-fargate-logging-policy \
                    --role-name eksctl-$CLUSTER_NAME-cluste-FargatePodExecutionRole-$RANDOM_ID""")

                updateR53();
            }
        }}
        stage('Restart Deployment') { when { expression { params.Deploy && params.Service != 'all' && params.Service != 'ingress' }}
            steps { script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 1) {
                    error(message: 'Cluster is not up so no need to update the deployment!')
                }
            }
            sh(script: "kubectl config set-context --current --namespace=$NAMESPACE")
            sh(script: "kubectl rollout restart deployment ${params.Service}")
        }}
        stage('Restart Ingress / ALB') { when { expression { params.Deploy && params.Service != 'all' && params.Service == 'ingress' }}
            steps { script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 1) {
                    error(message: 'Cluster is not up so no need to restart ingress')
                }
            }
            sh(script: "kubectl config set-context --current --namespace=$NAMESPACE")
            sh(script: "kubectl delete ingress -n $NAMESPACE eks-ingress")
            sh(script: "kubectl rollout restart deployment alb-ingress-controller -n kube-system")

            dir(path: './eks-context') {
                sh(script: "envsubst < ingress.yml | kubectl apply -f -")
                updateR53()
            }
        }}

        // Destroy EKS
        stage('Takedown EKS') { when { expression { !params.Deploy }}
            steps { script{
                def cluster_status = "$EKSCTL_CMD get cluster --region $AWS_REGION | grep -q $CLUSTER_NAME"
                def status = sh(returnStatus: true, script: cluster_status )
                if (status == 1) {
                    error(message: 'EKS Cluster does not exist!')
                }
            }

            dir(path: './eks-context') {
                echo(message: 'Taking Down Messages!')
                sh(script: """aws iam detach-role-policy \
                    --policy-arn arn:aws:iam::$ACCOUNT_ID:policy/eks-fargate-logging-policy \
                    --role-name eksctl-ootb-cluster-cluste-FargatePodExecutionRole-$RANDOM_ID""")

                sh(script: "$EKSCTL_CMD delete cluster --name $CLUSTER_NAME --region $AWS_REGION")
            }
        }}
    }
}

// --- --- Jenkins Methods --- ----
def getSecret(url, region) {
    def script = "aws secretsmanager get-secret-value --secret-id $url --region $region"
    def secret_value = sh(returnStdout: true, script: script)
    def secret_string = readJSON(text: secret_value).SecretString
    def secret_json = readJSON(text: secret_string)

    return secret_json;
}

def updateR53() {
    echo(message: 'Updating Route 53 records function!')

    def terraform_secret = getSecret(TERRAFORM_URL, AWS_REGION)

    def zoneId = terraform_secret["route53_zone_id"].toString();
    def record = terraform_secret["eks_url"].toString();

    def get_r53_script = """
        aws route53 list-resource-record-sets \
            --hosted-zone-id ${zoneId} \
            --query 'ResourceRecordSets[?Name == `${record}.`]' | jq -r .[].ResourceRecords[].Value"""
    def current_r53_record = sh(returnStdout: true, script: get_r53_script)

    String get_eks_lb = "";
    while (get_eks_lb.equals("")) {
        echo(message: 'Trying to get load balancer and update r53...')

        get_eks_lb = sh(returnStdout: true, script: "kubectl get ingress eks-ingress -o go-template='{{range.status.loadBalancer.ingress}}{{.hostname}}{{end}}'").trim()
        def lb_status = sh(returnStatus: true, script: "echo '${get_eks_lb}' | grep 'Error from server (NotFound)'")

        if (lb_status == 1 && get_eks_lb != "") {
            sh(script: """
            aws route53 change-resource-record-sets \
                --hosted-zone-id ${zoneId} \
                --change-batch '{"Changes": [{"Action": "UPSERT","ResourceRecordSet": {"Name": "'${record}'","Type": "CNAME","TTL": 300,"ResourceRecords": [{ "Value": "'${get_eks_lb}'" }]}}]}'
            """)
        } else {
            get_eks_lb = ""
        }

        sleep(time: 1, unit: 'SECONDS')
    }
}